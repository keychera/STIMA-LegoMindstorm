#pragma config(Sensor, S1,     touchSensor,    sensorEV3_Touch)
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          armMotor,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

float debug = -99;

//ADT Node
typedef struct sNode {
	int level;
	short decision[25];
	int nDec;
	int color;
} Node;

void InitNode(Node *n,int l,int c){
	(*n).level = l;
	(*n).nDec = 0;
	(*n).color = c;
}

void SetNode(Node *n,int l,int c){
	(*n).level = l;
	(*n).color = c;
}

void AddDec(Node *n,int d){
	(*n).decision[(*n).nDec] = d;
	(*n).nDec++;
}

//end of ADT Node

//ADT Queue
#define MAXQUEUE 25
#define Head(Q) (Q).head
#define Tail(Q) (Q).tail
#define InfoHead(Q) (Q).T[(Q).head]
#define InfoTail(Q) (Q).T[(Q).tail]
#define Element(Q,n) (Q).element[(n)]

typedef struct sQueue {
	int head;
	int tail;
	Node element[MAXQUEUE];
} Queue;

void CreateEmptyQ(Queue *Q){
	Head(*Q) = -1;
	Tail(*Q) = -1;
	int i;
	for(i = 0;i < MAXQUEUE;i++)
		InitNode(&(*Q).element[i],0,0);
}

int isEmpty(Queue Q){
	return (Head(Q) == -1);
}

int isOneElmt(Queue Q){
	return (Head(Q) == Tail(Q));
}

int isFull(Queue Q) {
	int n = Head(Q) - Tail(Q);
	return ((n == 1) || (n == (-1*MAXQUEUE) + 1));
}

int NbElmt(Queue Q) {
	if (Head(Q) == -1)
		return 0;
	else
		return (Head(Q) < Tail(Q))?
Tail(Q) - Head(Q) + 1 :
	MAXQUEUE - Tail(Q) + Head(Q) + 1;
}

void Enqueue(Queue *Q,Node n){
	if (!isFull(*Q)) {
		if (Head(*Q) == -1) Head(*Q) = 0;
		Tail(*Q)++;
		int locate = Tail(*Q);
	locate = (locate < MAXQUEUE)? locate : 0;
		SetNode(&Element(*Q,locate),n.level,n.color);
			if (n.nDec != 0){
				debug = n.nDec;
				int i;
				for(i = 0;i < n.nDec;i++)
					AddDec(&Element(*Q,locate),n.decision[i]);
		}
	}
}

void Dequeue(Queue *Q,Node *n){
	if (Head(*Q) != -1) {
		SetNode(&*n,Element(*Q,Head(*Q)).level,Element(*Q,Head(*Q)).color);
		if (Element(*Q,Head(*Q)).nDec != 0){
			int i;
			for(i = 0;i < Element(*Q,Head(*Q)).nDec;i++)
				AddDec(&*n,Element(*Q,Head(*Q)).decision[i]);
	}
		if (isOneElmt(*Q)){
			Head(*Q) = -1;
			Tail(*Q) = -1;
			} else {
			Head(*Q)++;
		Head(*Q) = (Head(*Q) < MAXQUEUE)? Head(*Q) : 0;
		}
	}
}

//end of ADT Queue

#define DEFAULTSPEED 50
#define FACTOR 0.25
#define gyroPort S2
#define colorPort S3

void moveForwardCont();
void stopMoving();
void moveForward(float n);

int TraceLineRoutine(int i);
int TraceUntilColor();

void BFSCoRoutine(int level);
void Traverse(Node n);
void TraverseBack(Node n);

int Color(int R,int G,int B);
int ScanColor(tSensors p,int *R, int *G, int *B);

void steerRight(int i);
void steerLeft(int i);
void steerRightAbit();
void steerLeftAbit();
void steerReverseRightAbit();
void steerReverseLeftAbit();

void turnNDegree(float n);
void turnCont(int c);
void turnRight();
void turnLeft();
void turnReverseRight();
void turnReverseLeft();


#define turnFactor 6.6795
#define waitFactor 50
#define threshold 70
#define colorThreshold 10

int color;
long R,G,B;
Queue BFS;
Node current;

//MAIN PROGRAM

task main()
{
	CreateEmptyQ(&BFS);
	InitNode(&current,0,-1);
	Node root;
	InitNode(&root,0,0);

	moveForward(3);

	TraceUntilColor();

	SetNode(&root,0,2);
	Enqueue(&BFS,root);

	int level = 0;
	int FireFound = 0;

	while(!isEmpty(BFS) && !FireFound) {
		Dequeue(&BFS,&current);
		if (current.color == 4)
			break;
		else {
			switch(current.color) {
				case 2 :
				if (level == current.level) {
					debug = 2;
					BFSCoRoutine(level);
				} else {
					debug = 3;
					if (level < current.level) {
						Traverse(current);
						BFSCoRoutine(level);
						TraverseBack(current);
					} else
					if (level > current.level+1) {
						//should be impossible?
						debug = 66;
					}
				}
				break;
				case 1:
					debug = 44;
					break;
				case 4:
					FireFound = 1;
					break;
			}
		}
	}

	/*
	sensorReset(colorPort);
	moveForward(3);

	while(1){
		getColorRGB(colorPort,R,G,B);
		color = Color(R,G,B);
		TraceLineRoutine(1);
		wait1Msec(waitFactor);
		if (color > 0) {
			turnRight();
			stopMoving();
			waitUntil(debug > 77);
		}
	}*/
}

//END OF MAIN PROGRAM

void FireDance(){

}

void BFSCoRoutine(int level){
	wait1Msec(100);
	int i;
	for(i = 0;i < 4;i++){
		if (i != 3){
			moveForward(0.25);
			turnRight();
			debug = 88 + i;
			ScanColor(colorSensor,&R,&G,&B);
			color = Color(R,G,B);
			if (color == 0){
				Node enter;
				TraceUntilColor();
				if ((color == 2) || (color == 4)) {
					InitNode(&enter,level+1,color);
					AddDec(&enter,i+1);
					Enqueue(&BFS,enter);
					if (color == 4) FireDance();
				}
				turnNDegree(180);
				TraceUntilColor();
			} else {
				turnNDegree(180);
			}
		} else {
			turnRight();
			moveForward(0.25);
			turnNDegree(180);
			moveForward(0.5);
		}
	}
}

void Traverse(Node n){
	int i;
	for(i = 0;i < n.nDec;i++){
		debug =  -1 * n.decision[i];
		switch(n.decision[i]){
			case 1:turnRight();break;
			case 2:moveForward(2);break;
			case 3:turnLeft();break;
		}
		TraceUntilColor();
	}
}

void TraverseBack(Node n){
	turnNDegree(180);
	debug = 42;
	wait1Msec(100);
	TraceUntilColor();
	int i;
	for(i = n.nDec-1;i == 0;i--){
		switch(n.decision[i]){
			case 1:turnLeft();break;
			case 2:moveForward(2);break;
			case 3:turnRight();break;
		}
		if (i != 0)
			TraceUntilColor();
		else{
			moveForward(0.25);
			turnNDegree(180);
			moveForward(0.5);
		}
	}
	debug = 41;
	wait1Msec(100);
}

int TraceLineRoutine(int i){
	//if the color is black or white
	if (getColorReflected(S3) < threshold){
		//sees dark
		steerRight(i);
		} else {
		//sees light
		steerLeft(i);
	}
	return 0;
}

int TraceUntilColor(){
	do {
		getColorRGB(colorPort,R,G,B);
		color = Color(R,G,B);
		TraceLineRoutine(1);
		wait1Msec(waitFactor);
	} while ((color == 0) || (color == 10)) ;
	return 0;
}

int Color(int R,int G,int B){
	//red = 1, green = 2, blue, 3,
	int out = 0;
	if ((G > 7 * colorThreshold)&& (B > 7 * colorThreshold) && (R > 7 * colorThreshold)){
		out = 10;
	} else
	if ((G > 7 * colorThreshold)&& (B < 2 * colorThreshold) && (R > 7 * colorThreshold)){
		out = 4;
	} else
	if ((G > R + colorThreshold)&& (G > B + colorThreshold)){
		out = 2;
	} else
	if ((B > G + colorThreshold)&& (B > R + colorThreshold)){
		out = 3;
	} else
		if ((R > G + colorThreshold)&& (R > B + colorThreshold)) {
		out = 1;
	}
	return out;
}

int ScanColor(tSensors p,int *R, int *G, int *B){
	getColorRGB(p,*R,*G,*B);
	return 0;
}

void steerRight(int i){
	motor[motorC] = 15 * i;
	motor[motorB] = 55 * i;
}

void steerLeft(int i){
	motor[motorC] = 55 * i;
	motor[motorB] = 15 * i;
}

void steerRightAbit(){
	steerRight(1);
	wait1Msec(waitFactor*3);
	stopMoving();
}

void steerReverseRightAbit(){
	steerRight(-1);
	wait1Msec(waitFactor*3);
	stopMoving();
}

void steerLeftAbit(){
	steerLeft(1);
	wait1Msec(waitFactor);
	stopMoving();
}

void steerReverseLeftAbit(){
	steerLeft(-1);
	wait1Msec(waitFactor);
	stopMoving();
}

void moveForwardCont(){
	motor[motorC] = DEFAULTSPEED;
	motor[motorB] = DEFAULTSPEED;
}

void stopMoving(){
	motor[motorC] = 0;
	motor[motorB] = 0;
}

void moveForward(float n){
	motor[motorC] = DEFAULTSPEED * (n/abs(n));
	motor[motorB] = DEFAULTSPEED * (n/abs(n));
	wait1Msec(abs(n) * 1000);
	motor[motorC] = 0;
	motor[motorB] = 0;
}


void turnNDegree(float n){
	//assuming n is Positive!
	resetGyro(gyroPort);
	motor[motorC] = 75;
	motor[motorB] = -75;
	waitUntil(abs(getGyroDegrees(gyroPort)) > 0.935*n - FACTOR*sqrt(n));
	motor[motorC] = 0;
	motor[motorB] = 0;
}

void turnCont(int c){
	motor[motorC] = -c;
	motor[motorB] = c;
}

void turnRight(){
	resetGyro(gyroPort);
	motor[motorC] = 19;
	motor[motorB] = 60;
	waitUntil(getGyroDegrees(gyroPort) > 90 - FACTOR*sqrt(90));
	motor[motorC] = 0;
	motor[motorB] = 0;
}

void turnReverseRight(){
	resetGyro(gyroPort);
	motor[motorC] = -19;
	motor[motorB] = -60;
	waitUntil(getGyroDegrees(gyroPort) < -90 + FACTOR*sqrt(90));
	motor[motorC] = 0;
	motor[motorB] = 0;
}

void turnLeft(){
	resetGyro(gyroPort);
	motor[motorC] = 65;
	motor[motorB] = 16;
	waitUntil(getGyroDegrees(gyroPort) < -90 + FACTOR*sqrt(90));
	motor[motorC] = 0;
	motor[motorB] = 0;
}

void turnReverseLeft(){
	resetGyro(gyroPort);
	motor[motorC] = -65;
	motor[motorB] = -16;
	waitUntil(getGyroDegrees(gyroPort) > 90 - FACTOR*sqrt(90));
	motor[motorC] = 0;
	motor[motorB] = 0;
}
