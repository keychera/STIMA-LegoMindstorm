#pragma config(Sensor, S1,     touchSensor,    sensorEV3_Touch)
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          armMotor,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//ADT Node
typedef struct sNode {
	int level;
	int decision;
	int color;
} Node;

void SetNode(Node *n,int l,int d,int c){
	(*n).level = l;
	(*n).decision = d;
	(*n).color = c;
}

//end of ADT Node

//ADT Queue
#define MAXQUEUE 50
#define Head(Q) (Q).head
#define Tail(Q) (Q).tail
#define InfoHead(Q) (Q).T[(Q).head]
#define InfoTail(Q) (Q).T[(Q).tail]
#define Element(Q,n) (Q).element[(n)]

typedef struct sQueue {
	int head;
	int tail;
	Node element[MAXQUEUE];
} Queue;

void CreateEmptyQ(Queue *Q){
	Head(*Q) = -1;
	Tail(*Q) = -1;
}

int isEmpty(Queue Q){
	return (Head(Q) == -1);
}

int isOneElmt(Queue Q){
	return (Head(Q) == Tail(Q));
}

int isFull(Queue Q) {
	int n = Head(Q) - Tail(Q);
	return ((n == 1) || (n == (-1*MAXQUEUE) + 1));
}

int NbElmt(Queue Q) {
	if (Head(Q) == -1)
		return 0;
	else
		return (Head(Q) < Tail(Q))?
							Tail(Q) - Head(Q) + 1 :
							MAXQUEUE - Tail(Q) + Head(Q) + 1;
}

void Enqueue(Queue *Q,Node n){
	if (!isFull(*Q)) {
		if (Head(*Q) == -1) Head(*Q) = 0;
		Tail(*Q)++;
		int locate = Tail(*Q);
		locate = (locate < MAXQUEUE)? locate : 0;
		Element(*Q,locate) = n;
	}
}

void Dequeue(Queue *Q,Node *n){
	if (Head(*Q) != -1) {
		*n = Element(*Q,Head(*Q));
		if (isOneElmt(*Q)){
			Head(*Q) = -1;
			Tail(*Q) = -1;
		} else {
			Head(*Q)++;
			Head(*Q) = (Head(*Q) < MAXQUEUE)? Head(*Q) : 0;
		}
	}
}

//end of ADT Queue

#define DEFAULTSPEED 50
#define gyroPort S2
#define colorPort S3

void moveForwardCont();
void stopMoving();
void moveForward(float n);

int BFSRoutine(Queue *Q,int level,Node checking);
int TraceLineRoutine(int i);

int Color(int R,int G,int B);
int ScanColor(tSensors p,int *R, int *G, int *B);

void steerRight(int i);
void steerLeft(int i);
void steerRightAbit();
void steerLeftAbit();
void steerReverseRightAbit();
void steerReverseLeftAbit();

void turnNDegree(float n);
void turnCont(int c);
void turnRight();
void turnLeft();
void turnReverseRight();
void turnReverseLeft();


#define turnFactor 6.6795
#define waitFactor 50
#define threshold 70
#define colorThreshold 10

float debug = -99;
int color;
long R,G,B;
static Node dummy = {-1,-1,-1};

//MAIN PROGRAM

task main()
{

	int level = 0;
	Queue BFS;
	CreateEmptyQ(&BFS);

	sensorReset(colorPort);
	moveForward(3);

	Node root;
	SetNode(&root,0,0,0);

	Enqueue(&BFS,root);
	BFSRoutine(&BFS,0,root);


	while(1){
		/*getColorRGB(colorPort,R,G,B);
		color = Color(R,G,B);


		TraceLineRoutine(1);
		wait1Msec(waitFactor);
		if (color > 0) {
			turnRight();
			stopMoving();
			waitUntil(debug > 77);
		}*/
	}
}

//END OF MAIN PROGRAM

int BFSRoutine(Queue *Q,int level,Node checking){
	do {
		getColorRGB(colorPort,R,G,B);
		color = Color(R,G,B);
		TraceLineRoutine(1);
		wait1Msec(waitFactor);
	} while (color == 0);
	if (color == 2){ //green
		Node checkQ;
		Dequeue(&*Q,&checkQ);
		if ((level == checking.level) && (checking.color == 0)){
			Node enter;
			SetNode(&enter,level,1,-1);
			Enqueue(&*Q,enter);
			SetNode(&enter,level,2,-1);
			Enqueue(&*Q,enter);
			SetNode(&enter,level,3,-1);
			Enqueue(&*Q,enter);
			Node checkQ;
			Dequeue(&*Q,&checkQ);
			turnRight();
			BFSRoutine(&*Q,level,checkQ);
		} else
		if (level > checking.level) {

		}
	} else
	if (color == 1) { //red
		steerReverseRightAbit();
		moveForward(-0.5);
		do {
		getColorRGB(colorPort,R,G,B);
		color = Color(R,G,B);
		TraceLineRoutine(-1);
		wait1Msec(waitFactor);
		} while (color == 0);
		turnReverseRight();
	}
	stopMoving();
	return 1;
}


int TraceLineRoutine(int i){
	//if the color is black or white
	if (getColorReflected(S3) < threshold){
		//sees dark
		steerRight(i);
	} else {
			//sees light
		steerLeft(i);
	}
	return 0;
}

int Color(int R,int G,int B){
	//red = 1, green = 2, blue, 3,
	int out = 0;
	if ((G > R + colorThreshold)&& (G > B + colorThreshold)){
		out = 2;
	} else
	if ((R > G + colorThreshold)&& (R > B + colorThreshold)) {
		out = 1;
	}
	return out;
}

int ScanColor(tSensors p,int *R, int *G, int *B){
		getColorRGB(p,*R,*G,*B);
		return 0;
}

void steerRight(int i){
	motor[motorC] = 15 * i;
	motor[motorB] = 55 * i;
}

void steerLeft(int i){
	motor[motorC] = 55 * i;
	motor[motorB] = 15 * i;
}

void steerRightAbit(){
	steerRight(1);
	wait1Msec(waitFactor);
	stopMoving();
}

void steerReverseRightAbit(){
	steerRight(-1);
	wait1Msec(waitFactor);
	stopMoving();
}

void steerLeftAbit(){
	steerLeft(1);
	wait1Msec(waitFactor);
	stopMoving();
}

void steerReverseLeftAbit(){
	steerLeft(-1);
	wait1Msec(waitFactor);
	stopMoving();
}

void moveForwardCont(){
	motor[motorC] = DEFAULTSPEED;
	motor[motorB] = DEFAULTSPEED;
}

void stopMoving(){
	motor[motorC] = 0;
	motor[motorB] = 0;
}

void moveForward(float n){
	motor[motorC] = DEFAULTSPEED * (n/abs(n));
	motor[motorB] = DEFAULTSPEED * (n/abs(n));
	wait1Msec(abs(n) * 1000);
	motor[motorC] = 0;
	motor[motorB] = 0;
}


void turnNDegree(float n){
	resetGyro(S2);
	motor[motorC] = 75;
	motor[motorB] = -75;
	if (n > 0)
		waitUntil(getGyroDegrees(gyroPort) > n - 0.25*sqrt(n));
	debug = getGyroDegrees(gyroPort);
	motor[motorC] = 0;
	motor[motorB] = 0;
}

void turnCont(int c){
	motor[motorC] = -c;
	motor[motorB] = c;
}

void turnRight(){
	resetGyro(S2);
	motor[motorC] = 19;
	motor[motorB] = 60;
	waitUntil(getGyroDegrees(gyroPort) > 90 - 0.25*sqrt(90));
	debug = getGyroDegrees(gyroPort);
	motor[motorC] = 0;
	motor[motorB] = 0;
}

void turnReverseRight(){
	resetGyro(S2);
	motor[motorC] = -19;
	motor[motorB] = -60;
	waitUntil(getGyroDegrees(gyroPort) < -90 + 0.25*sqrt(90));
	debug = getGyroDegrees(gyroPort);
	motor[motorC] = 0;
	motor[motorB] = 0;
}

void turnLeft(){
	resetGyro(S2);
	motor[motorC] = 65;
	motor[motorB] = 16;
	waitUntil(getGyroDegrees(gyroPort) < -90 + 0.25*sqrt(90));
	debug = getGyroDegrees(gyroPort);
	motor[motorC] = 0;
	motor[motorB] = 0;
}

void turnReverseLeft(){
	resetGyro(S2);
	motor[motorC] = -65;
	motor[motorB] = -16;
	waitUntil(getGyroDegrees(gyroPort) > 90 - 0.25*sqrt(90));
	debug = getGyroDegrees(gyroPort);
	motor[motorC] = 0;
	motor[motorB] = 0;
}
